/*
 * Copyright 2010 Stephen Liu
 * For license terms, see the file COPYING along with this library.
 */

#include "spdpclasscode.hpp"
#include "spdpname.hpp"
#include "spdpsyntax.hpp"

SP_DPClassCodeRender :: SP_DPClassCodeRender( SP_DPNameRender *nameRender )
{
	mNameRender = nameRender;
}

SP_DPClassCodeRender :: ~SP_DPClassCodeRender()
{
}

void SP_DPClassCodeRender :: generateHeader( SP_DPSyntaxTree * syntaxTree, FILE * writer )
{
	{
		char filename[ 128 ] = { 0 };
		mNameRender->getClassFileName( syntaxTree->getName(), filename, sizeof( filename ) );

		fprintf( writer, "/* %s.hpp\n", filename );
		fprintf( writer, "   Generated by spxml2struct from %s\n\n", syntaxTree->getDefineFile() );
		fprintf( writer, "   !!! DO NOT EDIT !!!\n\n" );
		fprintf( writer, "*/\n" );
		fprintf( writer, "\n" );

		fprintf( writer, "#pragma once\n" );
		fprintf( writer, "\n" );
	}

	{
		SP_DPSyntaxStructVector * slist = syntaxTree->getStructList();

		SP_DPSyntaxStructVector::iterator sit = slist->begin();

		for( ; slist->end() != sit; ++sit ) {
			generateDecl( &(*sit), writer );
		}

		fprintf( writer, "\n" );
	}

	{
		fprintf( writer, "\n" );
	}
}

void SP_DPClassCodeRender :: generateDecl( SP_DPSyntaxStruct * structure, FILE * writer )
{
	char className[ 128 ] = { 0 };

	mNameRender->getStructBaseName( structure->getName(), className, sizeof( className ) );

	fprintf( writer, "typedef struct tag%s %s_t;\n\n", className, className );

	fprintf( writer, "class %s {\n", className );
	fprintf( writer, "public:\n" );
	fprintf( writer, "\t%s();\n", className  );
	fprintf( writer, "\t~%s();\n\n", className );
	fprintf( writer, "\t%s( const %s & other );\n\n", className, className );
	fprintf( writer, "\t%s & operator=( const %s & other );\n\n", className, className );
	fprintf( writer, "\t%s_t * getImpl() const;\n\n", className );

	SP_DPSyntaxFieldVector * flist = structure->getFieldList();

	SP_DPSyntaxFieldVector::iterator fit = flist->begin();

	for( ; flist->end() != fit; ++fit ) {
		generateAccessorDecl( &(*fit), writer );

		fprintf( writer, "\n" );
	}

	fprintf( writer, "private:\n" );
	fprintf( writer, "\t%s_t * mImpl;\n", className );
	fprintf( writer, "};\n" );

	fprintf( writer, "\n" );
}

void SP_DPClassCodeRender :: generateAccessorDecl( SP_DPSyntaxField * field, FILE * writer )
{
	char typeName[ 128 ] = { 0 }, fieldName[ 128 ] = { 0 };

	mNameRender->getTypeName(field->getType(), typeName, sizeof(typeName));
	mNameRender->getFieldName(field->getName(), fieldName, sizeof(fieldName));

	if( field->getArraySize() > 0 ) {
		fprintf( writer, "\tvoid set%s( const %s * %s );\n", field->getName(), typeName, fieldName );
		fprintf( writer, "\tconst %s * get%s() const;\n", typeName, field->getName() );
	} else {
		if( mNameRender->isBaseType( field->getType() ) )
		{
			fprintf( writer, "\tvoid set%s( const %s %s );\n", field->getName(), typeName, fieldName );
			fprintf( writer, "\tconst %s get%s() const;\n", typeName, field->getName() );
		} else {
			fprintf( writer, "\tvoid set%s( const %s & %s );\n", field->getName(), typeName, fieldName );
			fprintf( writer, "\tconst %s * get%s() const;\n", typeName, field->getName() );
		}
	}
}

void SP_DPClassCodeRender :: generateCpp( SP_DPSyntaxTree * syntaxTree, FILE * writer )
{
	{
		char filename[ 128 ] = { 0 }, structFile[ 128 ] = { 0 };
		mNameRender->getClassFileName( syntaxTree->getName(), filename, sizeof( filename ) );
		mNameRender->getFileName( syntaxTree->getName(), structFile, sizeof( structFile ) );

		fprintf( writer, "/* %s.hpp\n", filename );
		fprintf( writer, "   Generated by spxml2struct from %s\n\n", syntaxTree->getDefineFile() );
		fprintf( writer, "   !!! DO NOT EDIT !!!\n\n" );
		fprintf( writer, "*/\n" );
		fprintf( writer, "\n" );

		fprintf( writer, "#include <stdlib.h>\n" );
		fprintf( writer, "#include <string.h>\n\n" );

		fprintf( writer, "#include \"%s.hpp\"\n", structFile );
		fprintf( writer, "#include \"%s.hpp\"\n", filename );
		fprintf( writer, "\n" );
	}

	{
		char pickleName[ 128 ] = { 0 };
		mNameRender->getPickleName( syntaxTree->getName(), pickleName, sizeof( pickleName ) );

		SP_DPSyntaxStructVector * slist = syntaxTree->getStructList();

		SP_DPSyntaxStructVector::iterator sit = slist->begin();

		for( ; slist->end() != sit; ++sit ) {
			generateImpl( pickleName, &(*sit), writer );

			fprintf( writer, "//============================================================\n\n" );
		}

		fprintf( writer, "\n" );
	}
}

void SP_DPClassCodeRender :: generateImpl( const char * pickleName, SP_DPSyntaxStruct * structure, FILE * writer )
{
	char className[ 128 ] = { 0 };
	mNameRender->getStructBaseName( structure->getName(), className, sizeof( className ) );

	fprintf( writer, "%s :: %s()\n", className, className );
	fprintf( writer, "{\n" );
	fprintf( writer, "\tmImpl = (%s_t*)calloc( sizeof( %s_t ), 1 );\n", className, className );
	fprintf( writer, "}\n\n" );

	fprintf( writer, "%s :: ~%s()\n", className, className );
	fprintf( writer, "{\n" );
	fprintf( writer, "\t%s::freeFields( *mImpl );\n", pickleName );
	fprintf( writer, "\tfree( mImpl );\n" );
	fprintf( writer, "\tmImpl = NULL;\n" );
	fprintf( writer, "}\n\n" );

	fprintf( writer, "%s :: %s( const %s & other )\n", className, className, className );
	fprintf( writer, "{\n" );
	fprintf( writer, "\tmImpl = NULL;\n" );
	fprintf( writer, "\toperator=( other );\n" );
	fprintf( writer, "}\n\n" );

	generateEval( pickleName, structure, writer );

	fprintf( writer, "%s_t * %s :: getImpl() const\n", className, className );
	fprintf( writer, "{\n" );
	fprintf( writer, "\treturn mImpl;\n" );
	fprintf( writer, "}\n\n" );

	SP_DPSyntaxFieldVector * flist = structure->getFieldList();

	SP_DPSyntaxFieldVector::iterator fit = flist->begin();

	for( ; flist->end() != fit; ++fit ) {
		generateAccessorImpl( className, &(*fit), writer );
	}
}

void SP_DPClassCodeRender :: generateEval( const char * pickleName, SP_DPSyntaxStruct * structure, FILE * writer )
{
	char className[ 128 ] = { 0 };
	mNameRender->getStructBaseName( structure->getName(), className, sizeof( className ) );

	fprintf( writer, "%s & %s :: operator=( const %s & other )\n", className, className, className );
	fprintf( writer, "{\n" );
	fprintf( writer, "\tif( NULL != mImpl )\n" );
	fprintf( writer, "\t{\n" );
	fprintf( writer, "\t\t%s::freeFields( *mImpl );\n", pickleName );
	fprintf( writer, "\t\tfree( mImpl );\n" );
	fprintf( writer, "\t\tmImpl = NULL;\n" );
	fprintf( writer, "\t}\n\n" );
	fprintf( writer, "\tmImpl = (%s_t*)calloc( sizeof( %s_t ), 1 );\n\n", className, className );
	fprintf( writer, "\t%s::deepCopy( mImpl, other.mImpl );\n", pickleName );
	fprintf( writer, "\n" );
	fprintf( writer, "\treturn *this;\n" );
	fprintf( writer, "}\n\n" );
}

void SP_DPClassCodeRender :: generateAccessorImpl( const char * className,
		SP_DPSyntaxField * field, FILE * writer )
{
	char typeName[ 128 ] = { 0 }, fieldName[ 128 ] = { 0 };

	mNameRender->getTypeName(field->getType(), typeName, sizeof(typeName));
	mNameRender->getFieldName(field->getName(), fieldName, sizeof(fieldName));

	if( field->getArraySize() > 0 ) {
		fprintf( writer, "void %s :: set%s( const %s * %s )\n",
				className, field->getName(), typeName, fieldName );
		fprintf( writer, "{\n" );
		if( strstr( field->getType(), "char" ) ) {
			fprintf( writer, "\tstrncpy( mImpl->%s, %s, sizeof( mImpl->%s ) - 1 );\n",
					fieldName, fieldName, fieldName );
		} else {
			fprintf( writer, "\tmImpl->%s = %s;\n", fieldName, fieldName );
		}
		fprintf( writer, "}\n\n" );
		fprintf( writer, "const %s * %s :: get%s() const\n", typeName, className, field->getName() );
		fprintf( writer, "{\n" );
		fprintf( writer, "\treturn mImpl->%s;\n", fieldName );
		fprintf( writer, "}\n\n" );
	} else {
		if( mNameRender->isBaseType( field->getType() ) ) {
			fprintf( writer, "void %s :: set%s( const %s %s )\n",
					className, field->getName(), typeName, fieldName );
			fprintf( writer, "{\n" );
			if( '*' == *( field->getType() ) && strstr( field->getType(), "char" ) ) {
				fprintf( writer, "\tif( mImpl->%s ) free( mImpl->%s );\n", fieldName, fieldName );
				fprintf( writer, "\tmImpl->%s = NULL;\n", fieldName );
				fprintf( writer, "\tif( %s ) mImpl->%s = strdup( %s );\n", fieldName, fieldName, fieldName );
			} else {
				fprintf( writer, "\tmImpl->%s = %s;\n", fieldName, fieldName );
			}
			fprintf( writer, "}\n\n" );

			fprintf( writer, "const %s %s :: get%s() const\n", typeName, className, field->getName() );
			fprintf( writer, "{\n" );
			fprintf( writer, "\treturn mImpl->%s;\n", fieldName );
			fprintf( writer, "}\n\n" );
		} else {
			fprintf( writer, "void %s :: set%s( const %s & %s )\n",
					className, field->getName(), typeName, fieldName );
			fprintf( writer, "{\n" );
			fprintf( writer, "\tmImpl->%s = %s;\n", fieldName, fieldName );

			fprintf( writer, "}\n\n" );

			fprintf( writer, "const %s * %s :: get%s() const\n", typeName, className, field->getName() );
			fprintf( writer, "{\n" );
			fprintf( writer, "\treturn &( mImpl->%s );\n", fieldName );
			fprintf( writer, "}\n\n" );
		}
	}
}

